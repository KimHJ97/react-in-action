# 네이버 스마트 에디터2

 - 공식 문서
    - 깃허브: https://github.com/naver/smarteditor2
    - 문서: https://naver.github.io/smarteditor2/user_guide/
 - 블로그
    - 사용 예시: https://junesker.tistory.com/16
    - 사용 예시: https://developer-mylee.tistory.com/37
    - 사용 예시: https://beforb.tistory.com/53
    - 사용 예시: https://je0ng-dev-log.tistory.com/49
    - 모달창 이슈: https://quantrader.tistory.com/141

<br/>

## 1. 사용 설명

 - 2.9.0 ~ 2.10.0 배포 파일에는 이미지 업로드 기능이 제외되어 있다.
 - 이미지 업로드가 포함되어 있는 버전은 2.8.2.3 배포 파일을 사용한다.

### 1-1. 주요 폴더 및 파일

 - /css 에디터에서 사용하는 CSS 파일.
 - /img: 에디터에서 사용하는 이미지 파일.
 - /js: 에디터를 설치할 때 사용하는 JavaScript 파일.
 - /quick_photo_uploader: 에디터의 사진 첨부 기능을 사용하기 위한 팝업 페이지(/popup)와 사진 첨부 기능을 구현한 JavaScript 파일(/plugin).
 - smart_editor2_inputarea.html: 에디터의 편집 영역을 나타내는 HTML 파일.
 - smart_editor2_inputarea_ie8.html: 에디터의 편집 영역을 나타내는 HTML 파일.
 - SmartEditor2.html: 에디터의 데모 페이지. 에디터를 설치할 때 참고할 수 있다.
 - SmartEditor2Skin.html: 에디터를 삽입한 페이지에서 로드하는 에디터의 스킨 HTML 파일.
 - readme.txt: 에디터에 대한 간략한 설명이 포함된 문서.
 - release_notes.txt: 릴리즈 시 수정되거나 개선된 사항에 대한 내용이 포함된 문서.
 - src_include.txt: 에디터 원본 소스를 수정하려고 할 때 참고해야 할 가이드 문서.
 - sample.php: 에디터에서 작성한 내용을 view 페이지에서 볼 수 있는 데모.

<br/>

### 1-1.

 - `에디터 요소 정의`
```html
<textarea id="editor" name="editor" rows="40" cols="10"></textarea>
```

 - `에디터 초기화`
   - oAppRef
   - elPlaceHolder: textarea 요소의 ID 값
   - sSkinURI: 에디터를 삽입한 페이지에서 로드하는 에디터의 스킨 HTML 파일
   - fCreator: 에디터 초기화 함수 지정 (createSEditor2를 입력, SE2BasicCreator.js의 createSEditor2가 사용됩니다.)
```javascript
let oEditors = [];

nhn.husky.EZCreator.createInIFrame({
   oAppRef: oEditors,
   elPlaceHolder: "editor",
   sSkinURI: "/static/bundle/smarteditor2/SmartEditor2Skin.html",
   fCreator: "createSEditor2"
});
```

## 2. 에디터 제어 함수

```javascript
let textareaId = 'editor';

// 에디터에 입력한 내용을 Textarea에 적용하기
oEditors.getById[textareaId].exec("UPDATE_CONTENTS_FIELD", []);

// 에디터에 내용 설정하기
oEditors.getById[textareaId].exec("SET_IR", ['내용']);
```

## 3. 이미지 업로드

이미지 업로드를 위해서는 sample/photo_uploader/attach_photo.js 파일을 수정해야 한다.

 - `attach_photo.js`
   - HTML5 미지원 브라우저용 (generalUpload)
       - 요청 방식: multipart/form-data (일반 폼 업로드)
       - 파일 필드명: id="uploadInputBox"에 연결된 jindo.FileUploader의 기본 필드명(라이브러리 기본값)을 사용
       - 서버에서는 단일 PartFile 하나만 받으면 된다.
       - 추가 제약(클라이언트 기준)
         - 확장자 허용: jpg, jpeg, png, gif, bmp
         - 1개 파일 최대: 10MB
         - 총 용량 최대: 50MB
         - 최대 갯수: 10장
         - (서버에서도 동일한 검증을 반드시 재확인하세요.)
   - HTML5 지원 브라우저용 (html5Upload)
      - 요청 방식: POST 본문에 파일 원시 바이너리 그대로 전송 (FormData 아님)
      - 요청 헤더(클라이언트가 세팅)
         - Content-Type: multipart/form-data (코드에 이렇게 박혀있지만 실제 몸체는 파일 바이너리)
            - → 서버쪽에선 진짜 멀티파트가 아님을 염두에 두고, 본문을 그대로 파일로 저장하면 됩니다.
         - file-name: encodeURIComponent(tempFile.name)
         - file-size: tempFile.size (바이트)
         - file-Type: tempFile.type (MIME)
      - 본문: 파일 바이너리 한 개
      - file_uploader_html5.php로 파일 1개씩 따로따로 전송되며, 서버는 헤더 3개 + 요청 본문(바이너리)을 사용해 저장/검증합니다.
```javascript
function uploadImage (e){
   if(!bSupportDragAndDropAPI){
      generalUpload();
   }else{
      html5Upload();
   }
}

// 기본 업로드 처리 부분
function generalUpload(){
   oFileUploader.upload();
}

// HTML5 업로드 처리 부분
function html5Upload() {	
   var tempFile,
      sUploadURL;

   sUploadURL= 'file_uploader_html5.php'; 	//upload URL

   //파일을 하나씩 보내고, 결과를 받음.
   for(var j=0, k=0; j < nImageInfoCnt; j++) {
      tempFile = htImageInfo['img'+j];
      try{
         if(!!tempFile){
            //Ajax통신하는 부분. 파일과 업로더할 url을 전달한다.
            callAjaxForHTML5(tempFile,sUploadURL);
            k += 1;
         }
      }catch(e){}
      tempFile = null;
   }
}
```
<br/>

 - `서버 응답 (generalUpload)`
   - 성공 시: oCustomEvent.htResult 객체가 필요하다.
   - __최소 필드(에디터에 삽입하려면 이 2개는 꼭)__
      - sFileName: 저장된 파일명 (예: "myimg.jpg")
      - sFileURL: 접근 가능한 이미지 URL (예: "https://cdn.example.com/img/myimg.jpg")
   - __선택 필드__
      - bNewLine: true/false (줄바꿈 여부, 클라이언트가 쓰면 반영)
      - 그 외 사이즈, 썸네일 URL 등은 자유
```json
// 성공
{ "sFileName": "myimg.jpg", "sFileURL": "https://cdn.example.com/img/myimg.jpg", "bNewLine": true }

// 실패
{ "errstr": "허용되지 않는 확장자입니다." }
```
<br/>

 - `서버 응답 (html5Upload)`
   - __성공 시: URL-encoded 쿼리스트링 한 줄로 반환해야 함__
      - 필수 키: sFileURL, sFileName (그리고 필요시 bNewLine=true)
   - __실패 시__
      - 확장자/타입 불가: NOTALLOW_<파일명> 형태의 plain text
      - 예: NOTALLOW_bad.exe
```javascript
sFileURL=https%3A%2F%2Fcdn.example.com%2Fimg%2Fmyimg.jpg&sFileName=myimg.jpg&bNewLine=true
```
<br/>

### 3-1. 서버 구현

 - `클라이언트 엔드포인트 변경`
```javascript
// HTML5 업로드(XHR)
function html5Upload() {
  var sUploadURL;
  sUploadURL = 'file_uploader_html5.php'; // ★여기 수정
  …
}

// 일반 업로드(iframe + Form)
// sUrl: 실제 업로드를 받는 서버 엔드포인트
// sCallback: 업로드 끝난 뒤 iframe이 redirect될 페이지 URL (라이브러리 규약용; success 핸들러에서 htResult를 받도록 맞춰져 있어야 함)
oFileUploader = new jindo.FileUploader(jindo.$("uploadInputBox"), {
  sUrl:      location.href.replace(/\/[^\/]*$/, '') + '/file_uploader.php',  // ★여기 수정 (업로드 수신 URL)
  sCallback: location.href.replace(/\/[^\/]*$/, '') + '/callback.html',      // ★여기 수정 (업로드 후 iframe이 이동할 콜백 페이지)
  …
})
```

 - `HTML5 업로드(XHR, 바이너리 본문)`
```java
@PostMapping(path = "/api/upload/image/html5")
public ResponseEntity<String> uploadHtml5(HttpServletRequest request) throws IOException {
    String fileName = URLDecoder.decode(request.getHeader("file-name"), StandardCharsets.UTF_8);
    String contentType = request.getHeader("file-Type");
    long size = Long.parseLong(request.getHeader("file-size"));

    // 1) 검증
    if (!fileName.matches("(?i).+\\.(jpg|jpeg|png|gif|bmp)$")) {
        return ResponseEntity.ok("NOTALLOW_" + fileName); // ★클라이언트 규약
    }
    if (size > 10 * 1024 * 1024L) { // 10MB
        return ResponseEntity.ok("NOTALLOW_" + fileName);
    }

    // 2) 바이너리 저장
    byte[] body = request.getInputStream().readAllBytes();
    Path saved = /* 원하는 경로 */ Files.createTempFile("img_", "_" + fileName);
    Files.write(saved, body);

    String publicUrl = "https://cdn.example.com/img/" + saved.getFileName(); // 실제 URL 로직으로 대체

    // 3) ★쿼리스트링 문자열로 반환 (URL-encoded 필수)
    String res = "sFileURL=" + URLEncoder.encode(publicUrl, StandardCharsets.UTF_8)
               + "&sFileName=" + URLEncoder.encode(fileName, StandardCharsets.UTF_8)
               + "&bNewLine=true";

    return ResponseEntity.ok()
            .contentType(MediaType.TEXT_PLAIN)
            .body(res);
}
```
</br>

 - `일반 업로드(multipart/form-data)`
```java
@PostMapping(path = "/api/upload/image/form", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public ResponseEntity<Map<String, Object>> uploadForm(@RequestPart("file") MultipartFile file) throws IOException {
    String fileName = file.getOriginalFilename();
    if (fileName == null) fileName = "unknown.bin";

    // 1) 검증
    if (!fileName.matches("(?i).+\\.(jpg|jpeg|png|gif|bmp)$")) {
        return ResponseEntity.ok(Map.of("errstr", "JPG, GIF, PNG, BMP 확장자만 가능합니다"));
    }
    if (file.getSize() > 10 * 1024 * 1024L) {
        return ResponseEntity.ok(Map.of("errstr", "이미지 용량이 10MB를 초과합니다."));
    }

    // 2) 저장
    Path saved = /* 원하는 경로 */ Files.createTempFile("img_", "_" + fileName);
    file.transferTo(saved);

    String publicUrl = "https://cdn.example.com/img/" + saved.getFileName();

    // 3) ★JSON 객체로 반환 (oCustomEvent.htResult에 그대로 들어감)
    Map<String, Object> htResult = new HashMap<>();
    htResult.put("sFileName", fileName);
    htResult.put("sFileURL", publicUrl);
    htResult.put("bNewLine", true);

    return ResponseEntity.ok(htResult);
}

```


## 4. 주의 사항

### 4-1. 모달창 주의 사항

Bootstrap 모달은 열리기 전엔 display:none이라, 그 상태에서 에디터를 만들면 iframe 사이즈가 0으로 계산되어 안 보이는 현상이 납니다.

 - `shown.bs.modal 콜백 이용`
   - 모달이 완전히 열린 뒤(shown.bs.modal)에 에디터 초기화 진행
```javascript
let oEditors = [];
let editorInited = false;

function initEditor() {
   nhn.husky.EZCreator.createInIFrame({
      oAppRef: oEditors,
      elPlaceHolder: "content",
      sSkinURI: "/bundle/smarteditor2/SmartEditor2Skin.html", // 경로 교정
      fCreator: "createSEditor2" // 오타 수정
   });
}

$('#modal').on('shown.bs.modal', function () {
   if (!editorInited) {
      initEditor();
      editorInited = true;
   }
});
```
<br/>


 - `HuskyEZCreator.js `
```javascript
// HuskyEZCreator.js 파일의 iframe ID 지정
try{
    elIFrame = document.createElement("<IFRAME frameborder=0 scrolling=no>");
}catch(e){
    elIFrame = document.createElement("IFRAME");
    elIFrame.setAttribute("frameborder", "0");
    elIFrame.setAttribute("scrolling", "no");
    elIFrame.setAttribute("id", elPlaceHolder.id + '_iframe'); // iframe ID 지정
}

// 새로 Editor 로딩 함수 정의
function reloadEditor() {
   let iframe = document.getElementById(iframeId);
   let srcUrl = iframe.getAttribute('src');
   iframe.setAttribute('src', srcUrl);
}
```
<br/>

 - `에디터 리사이징`
```javascript
function resizeEditor() {
   // 에디터 영역 다시 그리기
   let editorFrame = document.getElementById(this.textareaId + '_iframe');
   if (editorFrame) {
      editorFrame.style.width = '100%';
      editorFrame.style.minHeight = '254px';

      let iframeDocument = editorFrame.contentDocument || editorFrame.contentWindow.document;
      if (iframeDocument) {
            iframeDocument.querySelector("#smart_editor2").style.width = '100%';
            iframeDocument.querySelector(".se2_input_area").style.width = '100%';
      }

      // iframe 새로고침
      if (editorFrame.contentWindow) {
            try {
               editorFrame.contentWindow.document.body.style.visibility = 'visible';
            } catch (e) {
               console.warn('Cannot access iframe content:', e);
            }
      }
   }
}
```
