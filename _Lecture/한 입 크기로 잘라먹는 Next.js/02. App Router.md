# App Router

App Router는 13버전부터 도입된 새로운 라우팅 시스템으로, 기존의 Pages Router 방식과는 다른 방식으로 작동합니다. App Router는 더 유연하고, 컴포넌트 기반의 레이아웃 관리와 서버 컴포넌트(Server Components), 스트리밍(Streaming), 데이터 패칭(Data Fetching)의 새로운 방식 등을 지원합니다.

 - /app 디렉토리를 기반으로 라우팅이 이루어지는 파일 기반 라우팅 시스템

## 페이지 라우팅 설정

 - `주요 파일 및 개념`
    - layout.tsx: 공통 레이아웃을 정의하며 중첩 레이아웃(Nested Layout)을 지원
    - page.tsx: 해당 경로의 실제 페이지 컴포넌트
    - loading.tsx: 해당 페이지나 레이아웃이 로드될 때 보여줄 로딩 UI
    - error.tsx: 페이지에서 발생하는 오류 처리 UI
    - not-found.tsx: 404 페이지를 커스터마이징 할 수 있음
    - `[param]`: 동적 라우팅 (ex: `/blog/[slug]`)
<br/>

 - `폴더 구조 예시`
```
/app
  /about
    page.tsx
  /blog
    /[slug]
      page.tsx
  layout.tsx
  page.tsx
```
<br/>

 - `Route Group`
    - 괄호로 묶은 폴더는 라우팅에는 영향을 주지 않는 구조적 그룹화 용도로 사용한다.
    - /dashboard, /profile이라는 경로(URL)는 그대로 유지
    - (admin), (user) 폴더는 라우팅에 전혀 영향을 주지 않음
    - 단지 코드를 시멘틱하게 구분하거나 레이아웃을 나누기 위한 목적으로 사용됨
    - 사용 예시: 공통 레이아웃을 나누고 싶을 때, 기능 단위로 폴더를 묶고 싶지만 경로는 그대로 유지하고 싶을 때
```
/app
  /(admin)
    /dashboard
      page.tsx  → /dashboard
  /(user)
    /profile
      page.tsx  → /profile
```


## 리액트 서버 컴포넌트

서버 컴포넌트는 서버에서 렌더링되어 클라이언트에 HTML로 전송되는 컴포넌트입니다. 브라우저에서 실행되지 않고, 번들에도 포함되지 않으며, 클라이언트에 JS가 전혀 전송되지 않습니다.

 - React 18v부터 새롭게 추가된, 새로운 유형의 컴포넌트
 - 서버측에서만 실행되는 컴포넌트
    - 서버 컴포넌트: 서버측에서 사전 렌더링을 진행할 때 딱 한번만 실행됨
    - 클라이언트 컴포넌트: 사전 렌더링 진행할 때 한번, 하이드레이션 진행할 대 한번 총 2번 실행
 - `클라이언트 컴포넌트의 한계`
    - 모든 컴포넌트를 클라이언트에서 실행 → 초기 로딩 JS 번들 크기 증가
    - 데이터 패칭도 클라이언트에서 해야 함 → 복잡도 증가
 - `서버 컴포넌트 장점`
    - 더 작고 빠른 번들: JS를 클라이언트에 보내지 않음
    - 더 쉬운 데이터 패칭: async/await로 서버에서 API, DB 호출
    - 민감한 데이터 보호: 클라이언트에 노출되지 않음 (예: API 키, DB 쿼리)
    - 자동 스트리밍 렌더링: 일부만 먼저 렌더링해서 빠른 사용자 경험 제공

<br/>

### 서버 컴포넌트 주의사항

 - `요약`
    - 서버에 브라우저 코드 사용
        - 설명: window, useState 등 금지
        - 해결 방법: 'use client' 컴포넌트로 분리
    - 클라이언트 컴포넌트도 SSR됨
        - 설명: 서버에서 HTML 먼저 렌더링됨
        - 해결 방법: 클라이언트 전용 코드도 SSR 고려
    - 클라이언트 → 서버 import ❌
        - 설명: 서버 컴포넌트는 클라이언트 번들 불가
        - 핵려 방법: 상위에서 서버 → 클라이언트로 분리
    - 비직렬화 props 전달 ❌
        - 설명: 함수 등 전달 시 에러 발생
        - 해결 방법: props는 JSON 가능한 값만 사용

 - `1. 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안 된다.`
    - 서버 컴포넌트는 Node.js 서버에서 실행되고, 브라우저에서는 HTML만 렌더링됩니다.
    - 즉, 브라우저 전용 코드 (window, document, useEffect, useState, 이벤트 핸들러 등)를 절대 포함하면 안 됩니다.
```javascript
// ❌ 서버 컴포넌트 안에서 브라우저 API 사용
export default function Page() {
  console.log(window.location.href); // 런타임 에러 발생
  return <div>Page</div>;
}
```
<br/>

 - `2. 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다.`
    - 클라이언트 컴포넌트는 'use client'를 붙이면 브라우저에서 실행되는 JS 번들에 포함되지만, 초기 렌더링은 서버에서 HTML로도 먼저 그려집니다.
    - 서버에서 먼저 HTML로 렌더링 -> 클라이언트에서 JS 번들을 받아 하이드레이션됨 -> 이후 useState, onClick 등 이벤트 작동 가능
```javascript
'use client'

export default function Button() {
  return <button>Click Me</button>
}
```
<br/>

 - `3. 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다.`
    - 클라이언트 컴포넌트는 서버와 브라우저에서 모두 실행된다. 서버 컴포넌트는 오직 서버에서만 실행된다. 서버 컴포넌트는 JS 번들에서 제외된다.
    - Next.js는 클라이언트 컴포넌트에서 서버 컴포넌트를 import 하면, 서버 컴포넌트를 클라이언트 컴포넌트로 자동으로 변경한다.
```typescript
// 1. ❌ 예시
// 서버측: ClientComponent, ServerCompoennt 실행
// 클라이언트측: 하이드레이션 과정에서 ClientComponent 실행. ServerComponent는 존재하지 않음 (에러)
"use client";
import ServerComponent from "./server-component.tsx";
export default function ClientComponent() {
    return <ServerComponent />;
}

export default function ServerComponent() {
    return <div>서버 컴포넌트</div>;
}

// 2. ✅ 해결 방안: 클라이언트 컴포넌트에서 서버 컴포넌트를 children으로 받아서 사용
export default function Home() {
    return (
        <div className={styled.page}>
            인덱스 페이지
            <ClientComponent>
                <ServerComponent />
            <ClientComponent>
        </div>
    );
}

"use client";
export default function ClientComponent({
    children
}: { 
    children: ReactNod;

}) {
    return <div>{children}</div>;
}
```
 

 -  `4. 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화되지 않는 Props는 전달 불가하다.`
    - 서버 컴포넌트는 클라이언트 컴포넌트에게 props를 줄 수 있지만, 이때 전달되는 props는 JSON으로 직렬화(serialize) 되어야 합니다.
    - 함수, 클래스 인스턴스, Symbol, Date, BigInt 등은 직렬화 불가능 → ❌ 오류
```javascript
// 1. ❌ 예시 (오류 발생)
// Server Component
import ClientComponent from './ClientComponent';

export default function Server() {
  const callback = () => alert('hi'); // ❌ 함수는 직렬화 안됨

  return <ClientComponent onClick={callback} />;
}

// ClientComponent.tsx
'use client'
export default function ClientComponent({ onClick }) {
  return <button onClick={onClick}>Click</button>;
}
```
